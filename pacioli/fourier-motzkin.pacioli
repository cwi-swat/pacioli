let eliminate(quadruples, row) =
  let combined = [tuple(scaled1, support(scaled1), scaled2, support(scaled2)) |
                      (v,w) in combis(quadruples),
                      (v1,sv1,v2,sv2) := v,
                      (w1,sw1,w2,sw2) := w,
                      alpha := magnitude(v1,row,empty), 
                      beta := magnitude(w1,row,empty),
                      alpha*beta < 0,
                      scaled1 := scale(abs(beta),v1) + scale(abs(alpha),w1),
                      scaled2 := scale(abs(beta),v2) + scale(abs(alpha),w2)]
  in
    [q | q in append(combined, quadruples), (v1, support1, v2, support2) := q, magnitude(v1, row, empty) = 0]
  end
in  					    
 let canonical(quadruple) =
   let (v1, support1, v2, support2) = quadruple in
     let c = 1 / gcd(gcd[magnitude(v1,i,j) | i,j from v1],
                     gcd[magnitude(v2,i,j) | i,j from v2]) in
       tuple(scale(c,v1), support1, scale(c,v2), support2)
     end
   end
 in                                
  let filterMinimals(quadruples) =
    [q | q in quadruples,
         (q1,sq1,q2,sq2) := q,
         all[(sr1<=sq1 && sr2<=sq2) ==> (sq1=sr1 && sq2=sr2) | (r1,sr1,r2,sr2) in quadruples]]
  in
   let fourierMotzkin(matrix) =
     [v2 | (v1, support1, v2, support2) in 
               loopList([tuple(v1, support(v1), v2, support(v2)) |
                             (v1,v2) in zip(columns(matrix), columns(rightIdentity(matrix)))],
                        lambda(quadruples, row) filterMinimals([canonical(v) | v in eliminate(quadruples, row)]),
                        rowDomain(matrix))]
   in
     fourierMotzkin(backward-forward)
   end
  end
 end
end