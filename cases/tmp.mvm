baseunit dollar "$";
baseunit euro "ï¿½";
baseunit each "each";
baseunit bag "bag";
baseunit case "case";
baseunit can "can";
baseunit tub "tub";
baseunit gal "gal";
baseunit roll "roll";
baseunit sleeve "sleeve";
baseunit box "box";
baseunit bottle "bottle";
baseunit loc "loc";
baseunit bit "bit";
unit byte "byte" 8*bit;
unit hour "hr" 3600*second;
unit litre "l" (deci metre)^3;
unit pound "lb" 0.45359237*kilo gram;
unit ounce "oz" pound/16;
unit barrel "bbl" 117.347765*litre;
entity Product "/home/paul/data/code/cwi/pacioli/cases/case1/product.entity";
index Product bom_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.bom_unit";
index Product trade_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.trade_unit";
entity Commodity "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.entity";
entity Year "/home/paul/data/code/cwi/pacioli/cases/case2/year.entity";
entity Region "/home/paul/data/code/cwi/pacioli/cases/case2/region.entity";
index Commodity unit "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.unit";
entity Ingredient "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.entity";
entity Menu "/home/paul/data/code/cwi/pacioli/cases/case3/menu.entity";
index Ingredient unit "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.unit";
conversion conv "Product" "bom_unit" "trade_unit";
projection P0 "Commodity,Year,Region.1" "Commodity.1";
projection P1 "Commodity,Year,Region.1" "Commodity,Year.1";
projection P2 "Year,Commodity.1,unit" "Commodity,Year,Region.unit,1,1";
entity Place "/home/paul/data/code/cwi/pacioli/cases/case4/place.entity";
entity Transition "/home/paul/data/code/cwi/pacioli/cases/case4/transition.entity";
index Place unit "/home/paul/data/code/cwi/pacioli/cases/case4/place.unit";
entity File "/home/paul/data/code/cwi/pacioli/cases/case5/file.entity";
entity Module "/home/paul/data/code/cwi/pacioli/cases/case5/module.entity";
load lines "/home/paul/data/code/cwi/pacioli/cases/case5/lines.csv" "loc" "empty" "File.1.0";
load semi_bom "/home/paul/data/code/cwi/pacioli/cases/case3/semi_bom.csv" "1.0" "Ingredient.unit" "Menu.1.0";
load menu_price "/home/paul/data/code/cwi/pacioli/cases/case3/menu_price.csv" "dollar" "empty" "Menu.1.0";
load backward "/home/paul/data/code/cwi/pacioli/cases/case4/backward.csv" "1.0" "Place.unit" "Transition.1.0";
load root "/home/paul/data/code/cwi/pacioli/cases/case5/root.csv" "1.0" "Module.1.0" "empty";
load stock2 "/home/paul/data/code/cwi/pacioli/cases/case3/stock2.csv" "1.0" "Ingredient.unit" "empty";
load stock1 "/home/paul/data/code/cwi/pacioli/cases/case3/stock1.csv" "1.0" "Ingredient.unit" "empty";
load ingredient_price "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient_price.csv" "dollar" "empty" "Ingredient.unit";
load amount "/home/paul/data/code/cwi/pacioli/cases/case2/amount.csv" "1.0" "Commodity,Year,Region.unit,1.0,1.0" "empty";
load sales_price "/home/paul/data/code/cwi/pacioli/cases/case1/sales_price.csv" "dollar" "empty" "Product.trade_unit";
load forward "/home/paul/data/code/cwi/pacioli/cases/case4/forward.csv" "1.0" "Place.unit" "Transition.1.0";
load bom "/home/paul/data/code/cwi/pacioli/cases/case1/bom.csv" "1.0" "Product.bom_unit" "Product.bom_unit";
load owner "/home/paul/data/code/cwi/pacioli/cases/case5/owner.csv" "1.0" "File.1.0" "Module.1.0";
load menu_sales "/home/paul/data/code/cwi/pacioli/cases/case3/menu_sales.csv" "1.0" "Menu.1.0" "empty";
load parent "/home/paul/data/code/cwi/pacioli/cases/case5/parent.csv" "1.0" "Module.1.0" "Module.1.0";
load fileSize "/home/paul/data/code/cwi/pacioli/cases/case5/fileSize.csv" "byte" "empty" "File.1.0";
load sales "/home/paul/data/code/cwi/pacioli/cases/case2/sales.csv" "dollar" "empty" "Commodity,Year,Region.1.0";
load purchase_price "/home/paul/data/code/cwi/pacioli/cases/case1/purchase_price.csv" "dollar" "empty" "Product.trade_unit";
load output "/home/paul/data/code/cwi/pacioli/cases/case1/output.csv" "1.0" "Product.trade_unit" "empty";
load valuation "/home/paul/data/code/cwi/pacioli/cases/case4/valuation.csv" "dollar" "empty" "Place.unit";
eval flow application(sum, backward, application(negative, forward));
eval empty application(head, application(loopMatrix, emptyList, lambda (accu, i, j) application(addMut, accu, j), application(head, application(columns, flow))));
eval combis lambda (list) application(apply, lambda (x, y) x, application(reduceList, application(tuple,emptyList,list), lambda (x) x, lambda (accu, x) application(apply, lambda (a, b) application(tuple,application(append, application(loopList, emptyList, lambda (accu, y) application(addMut, accu, application(tuple,x,y)), application(tail, b)), a),application(tail, b)), accu), list));
eval supportLess lambda (a, b) application(lambda (a1) application(lambda (a2) application(lambda (b1) application(lambda (b2) and(application(less, application(multiply, a1, application(reciprocal, a1)), application(multiply, b1, application(reciprocal, b1))),application(less, application(multiply, a2, application(reciprocal, a2)), application(multiply, b2, application(reciprocal, b2)))), application(apply, second, b)), application(apply, first, b)), application(apply, second, a)), application(apply, first, a));
eval gcd lambda (x, y) application(lambda (iter) if(application(less, x, 0.00),application(gcd, application(negative, x), y),if(application(less, y, 0.00),application(gcd, x, application(negative, y)),application(iter, x, y))), lambda (a, b) if(application(equal, a, 0.00),b,if(application(equal, b, 0.00),a,if(application(lessEq, x, y),application(gcd, x, application(mod, y, x)),application(gcd, application(mod, x, y), y)))));
eval canonical lambda (vec) application(lambda (v1) application(lambda (v2) application(lambda (c) application(tuple,application(scale, application(multiply, 1.00, application(reciprocal, c)), v1),application(scale, application(multiply, 1.00, application(reciprocal, c)), v2)), application(reduceList, 0.00, identity, gcd, application(append, application(loopMatrix, emptyList, lambda (accu, i, j) application(loopList, accu, lambda (accu, m) if(application(not, application(equal, m, 0.00)),application(addMut, accu, m),accu), application(singletonList, application(magnitude, v1, i, j))), v1), application(loopMatrix, emptyList, lambda (accu, i, j) application(loopList, accu, lambda (accu, m) if(application(not, application(equal, m, 0.00)),application(addMut, accu, m),accu), application(singletonList, application(magnitude, v2, i, j))), v2)))), application(apply, second, vec)), application(apply, first, vec));
eval supportLessEq lambda (a, b) application(lambda (a1) application(lambda (a2) application(lambda (b1) application(lambda (b2) and(application(lessEq, application(multiply, a1, application(reciprocal, a1)), application(multiply, b1, application(reciprocal, b1))),application(lessEq, application(multiply, a2, application(reciprocal, a2)), application(multiply, b2, application(reciprocal, b2)))), application(apply, second, b)), application(apply, first, b)), application(apply, second, a)), application(apply, first, a));
eval second lambda (x, y) y;
eval eliminate lambda (pairs, row) application(loopList, emptyList, lambda (accu, c) application(loopList, accu, lambda (accu, x) application(loopList, accu, lambda (accu, y) application(loopList, accu, lambda (accu, v) application(loopList, accu, lambda (accu, w) application(loopList, accu, lambda (accu, vv) application(loopList, accu, lambda (accu, ww) application(loopList, accu, lambda (accu, alpha) application(loopList, accu, lambda (accu, beta) if(application(less, application(multiply, alpha, beta), 0.00),if(application(not, or(application(equal, alpha, 0.00),application(equal, beta, 0.00))),application(addMut, accu, application(tuple,application(sum, application(scale, application(abs, beta), v), application(scale, application(abs, alpha), w)),application(sum, application(scale, application(abs, beta), vv), application(scale, application(abs, alpha), ww)))),accu),accu), application(singletonList, application(magnitude, w, row, empty))), application(singletonList, application(magnitude, v, row, empty))), application(singletonList, application(apply, second, y))), application(singletonList, application(apply, second, x))), application(singletonList, application(apply, first, y))), application(singletonList, application(apply, first, x))), application(singletonList, application(apply, second, c))), application(singletonList, application(apply, first, c))), application(combis, pairs));
eval first lambda (x, y) x;
eval result application(lambda (rowList) application(lambda (cols) application(lambda (idents) application(lambda (pairs) application(lambda (driver) application(loopList, emptyList, lambda (accu, p) application(addMut, accu, application(apply, second, p)), application(reduceList, pairs, identity, driver, rowList)), lambda (pairs, row) application(lambda (eli) application(lambda (tmp) application(lambda (res) application(lambda (dummy) res, application(print, application(tuple,row,application(size, eli),application(size, tmp),application(size, res)))), application(loopList, emptyList, lambda (accu, t) if(application(loopList, true, lambda (accu, y) if(application(not, application(equal, y, t)),and(accu,application(not, application(supportLessEq, y, t))),accu), tmp),application(addMut, accu, t),accu), tmp)), application(loopList, emptyList, lambda (accu, v) application(loopList, accu, lambda (accu, v1) application(loopList, accu, lambda (accu, v2) if(application(equal, application(magnitude, v1, row, empty), 0.00),application(addMut, accu, application(canonical, v)),accu), application(singletonList, application(apply, second, v))), application(singletonList, application(apply, first, v))), application(append, eli, pairs))), application(eliminate, pairs, row))), application(zip, cols, idents)), application(columns, application(rightIdentity, flow))), application(columns, flow)), application(loopMatrix, emptyList, lambda (accu, i, j) application(addMut, accu, i), application(head, application(columns, forward)))); 
print result