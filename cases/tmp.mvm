baseunit dollar "$";
baseunit euro "ï¿½";
baseunit each "each";
baseunit bag "bag";
baseunit case "case";
baseunit can "can";
baseunit tub "tub";
baseunit gal "gal";
baseunit roll "roll";
baseunit sleeve "sleeve";
baseunit box "box";
baseunit bottle "bottle";
baseunit loc "loc";
baseunit bit "bit";
unit byte "byte" 8*bit;
unit hour "hr" 3600*second;
unit litre "l" (deci metre)^3;
unit pound "lb" 0.45359237*kilo gram;
unit ounce "oz" pound/16;
unit barrel "bbl" 117.347765*litre;
entity Product "/home/paul/data/code/cwi/pacioli/cases/case1/product.entity";
index Product bom_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.bom_unit";
index Product trade_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.trade_unit";
entity Commodity "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.entity";
entity Year "/home/paul/data/code/cwi/pacioli/cases/case2/year.entity";
entity Region "/home/paul/data/code/cwi/pacioli/cases/case2/region.entity";
index Commodity unit "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.unit";
entity Ingredient "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.entity";
entity Menu "/home/paul/data/code/cwi/pacioli/cases/case3/menu.entity";
index Ingredient unit "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.unit";
conversion conv "Product" "bom_unit" "trade_unit";
projection P0 "Commodity,Year,Region.1" "Commodity.1";
projection P1 "Commodity,Year,Region.1" "Commodity,Year.1";
projection P2 "Year,Commodity.1,unit" "Commodity,Year,Region.unit,1,1";
entity Place "/home/paul/data/code/cwi/pacioli/cases/case4/place.entity";
entity Transition "/home/paul/data/code/cwi/pacioli/cases/case4/transition.entity";
index Place unit "/home/paul/data/code/cwi/pacioli/cases/case4/place.unit";
entity File "/home/paul/data/code/cwi/pacioli/cases/case5/file.entity";
entity Module "/home/paul/data/code/cwi/pacioli/cases/case5/module.entity";
load lines "/home/paul/data/code/cwi/pacioli/cases/case5/lines.csv" "loc" "empty" "File.1.0";
load semi_bom "/home/paul/data/code/cwi/pacioli/cases/case3/semi_bom.csv" "1.0" "Ingredient.unit" "Menu.1.0";
load menu_price "/home/paul/data/code/cwi/pacioli/cases/case3/menu_price.csv" "dollar" "empty" "Menu.1.0";
load backward "/home/paul/data/code/cwi/pacioli/cases/case4/backward.csv" "1.0" "Place.unit" "Transition.1.0";
load root "/home/paul/data/code/cwi/pacioli/cases/case5/root.csv" "1.0" "Module.1.0" "empty";
load stock2 "/home/paul/data/code/cwi/pacioli/cases/case3/stock2.csv" "1.0" "Ingredient.unit" "empty";
load stock1 "/home/paul/data/code/cwi/pacioli/cases/case3/stock1.csv" "1.0" "Ingredient.unit" "empty";
load ingredient_price "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient_price.csv" "dollar" "empty" "Ingredient.unit";
load amount "/home/paul/data/code/cwi/pacioli/cases/case2/amount.csv" "1.0" "Commodity,Year,Region.unit,1.0,1.0" "empty";
load sales_price "/home/paul/data/code/cwi/pacioli/cases/case1/sales_price.csv" "dollar" "empty" "Product.trade_unit";
load forward "/home/paul/data/code/cwi/pacioli/cases/case4/forward.csv" "1.0" "Place.unit" "Transition.1.0";
load bom "/home/paul/data/code/cwi/pacioli/cases/case1/bom.csv" "1.0" "Product.bom_unit" "Product.bom_unit";
load owner "/home/paul/data/code/cwi/pacioli/cases/case5/owner.csv" "1.0" "File.1.0" "Module.1.0";
load menu_sales "/home/paul/data/code/cwi/pacioli/cases/case3/menu_sales.csv" "1.0" "Menu.1.0" "empty";
load parent "/home/paul/data/code/cwi/pacioli/cases/case5/parent.csv" "1.0" "Module.1.0" "Module.1.0";
load sales "/home/paul/data/code/cwi/pacioli/cases/case2/sales.csv" "dollar" "empty" "Commodity,Year,Region.1.0";
load purchase_price "/home/paul/data/code/cwi/pacioli/cases/case1/purchase_price.csv" "dollar" "empty" "Product.trade_unit";
load output "/home/paul/data/code/cwi/pacioli/cases/case1/output.csv" "1.0" "Product.trade_unit" "empty";
load size "/home/paul/data/code/cwi/pacioli/cases/case5/size.csv" "byte" "empty" "File.1.0";
load valuation "/home/paul/data/code/cwi/pacioli/cases/case4/valuation.csv" "dollar" "empty" "Place.unit";
eval flow application(sum, backward, application(negative, forward));
eval empty application(head, application(application(reduceMatrix, lambda (yo) emptyList, lambda (i, j) lambda (yo) application(singletonList, j), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(head, application(columns, flow))), 1.0));
eval combis lambda (list) application(apply, lambda (x, y) x, application(reduceList, application(tuple,emptyList,list), lambda (x) x, lambda (accu, x) application(apply, lambda (a, b) application(tuple,application(append, application(application(reduce, lambda (yo) emptyList, lambda (y) lambda (yo) application(singletonList, application(tuple,x,y)), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(tail, b)), 1.0), a),application(tail, b)), accu), list));
eval canonical lambda (vec) application(lambda (v1) application(lambda (v2) application(lambda (c) application(tuple,application(scale, application(multiply, 1.00, application(reciprocal, c)), v1),application(scale, application(multiply, 1.00, application(reciprocal, c)), v2)), application(reduceList, 0.00, identity, gcd, application(append, application(application(reduceMatrix, lambda (yo) emptyList, lambda (i, j) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (m) lambda (yo) application(if(application(not, application(equal, m, 0.00)),lambda (yo) application(singletonList, m),lambda (yo) emptyList), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(magnitude, v1, i, j))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), v1), 1.0), application(application(reduceMatrix, lambda (yo) emptyList, lambda (i, j) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (m) lambda (yo) application(if(application(not, application(equal, m, 0.00)),lambda (yo) application(singletonList, m),lambda (yo) emptyList), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(magnitude, v2, i, j))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), v2), 1.0)))), application(apply, second, vec)), application(apply, first, vec));
eval supportLessEq lambda (a, b) application(lambda (a1) application(lambda (a2) application(lambda (b1) application(lambda (b2) and(application(lessEq, application(multiply, a1, application(reciprocal, a1)), application(multiply, b1, application(reciprocal, b1))),application(lessEq, application(multiply, a2, application(reciprocal, a2)), application(multiply, b2, application(reciprocal, b2)))), application(apply, second, b)), application(apply, first, b)), application(apply, second, a)), application(apply, first, a));
eval second lambda (x, y) y;
eval eliminate lambda (pairs, row) application(application(reduce, lambda (yo) emptyList, lambda (c) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (x) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (y) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (v) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (w) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (vv) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (ww) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (alpha) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (beta) lambda (yo) application(if(application(lessEq, application(multiply, alpha, beta), 0.00),lambda (yo) application(if(application(not, or(application(equal, alpha, 0.00),application(equal, beta, 0.00))),lambda (yo) application(singletonList, application(tuple,application(sum, application(scale, application(abs, beta), v), application(scale, application(abs, alpha), w)),application(sum, application(scale, application(abs, beta), vv), application(scale, application(abs, alpha), ww)))),lambda (yo) emptyList), 1.0),lambda (yo) emptyList), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(magnitude, w, row, empty))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(magnitude, v, row, empty))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, second, y))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, second, x))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, first, y))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, first, x))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, second, c))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, first, c))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(combis, pairs)), 1.0);
eval first lambda (x, y) x;
eval result application(lambda (rowList) application(lambda (cols) application(lambda (idents) application(lambda (pairs) application(lambda (driver) application(application(reduce, lambda (yo) emptyList, lambda (p) lambda (yo) application(singletonList, application(apply, second, p)), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(reduceList, pairs, identity, driver, rowList)), 1.0), lambda (pairs, row) application(lambda (eli) application(lambda (tmp) application(lambda (res) application(lambda (dummy) res, application(print, application(tuple,row,application(application(reduce, lambda (yo) 0.0, lambda (x) lambda (yo) application(lambda (x) 1.0, x), lambda (x, y) lambda (yo) application(sum, application(x, 1.0), application(y, 1.0)), res), 1.0)))), application(application(reduce, lambda (yo) emptyList, lambda (t) lambda (yo) application(if(application(application(reduce, lambda (yo) true, lambda (y) lambda (yo) application(identity, application(not, and(application(supportLessEq, y, t),application(not, application(equal, y, t))))), lambda (x, y) lambda (yo) and(application(x, 1.0),application(y, 1.0)), tmp), 1.0),lambda (yo) application(singletonList, t),lambda (yo) emptyList), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), tmp), 1.0)), application(application(reduce, lambda (yo) emptyList, lambda (v) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (v1) lambda (yo) application(application(reduce, lambda (yo) emptyList, lambda (v2) lambda (yo) application(if(application(equal, application(magnitude, v1, row, empty), 0.00),lambda (yo) application(singletonList, application(canonical, v)),lambda (yo) emptyList), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, second, v))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(singletonList, application(apply, first, v))), 1.0), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(append, eli, pairs)), 1.0)), application(eliminate, pairs, row))), application(zip, cols, idents)), application(columns, application(rightIdentity, flow))), application(columns, flow)), application(application(reduceMatrix, lambda (yo) emptyList, lambda (i, j) lambda (yo) application(singletonList, i), lambda (x, y) lambda (yo) application(append, application(x, 1.0), application(y, 1.0)), application(head, application(columns, forward))), 1.0)); 
print result