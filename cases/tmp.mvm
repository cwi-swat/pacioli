baseunit dollar "$";
baseunit euro "ï¿½";
baseunit each "each";
baseunit bag "bag";
baseunit case "case";
baseunit can "can";
baseunit tub "tub";
baseunit gal "gal";
baseunit roll "roll";
baseunit sleeve "sleeve";
baseunit box "box";
baseunit bottle "bottle";
baseunit loc "loc";
baseunit bit "bit";
unit byte "byte" 8*bit;
unit hour "hr" 3600*second;
unit litre "l" (deci metre)^3;
unit pound "lb" 0.45359237*kilo gram;
unit ounce "oz" pound/16;
unit barrel "bbl" 117.347765*litre;
entity Product "/home/paul/data/code/cwi/pacioli/cases/case1/product.entity";
index Product bom_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.bom_unit";
index Product trade_unit "/home/paul/data/code/cwi/pacioli/cases/case1/product.trade_unit";
entity Commodity "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.entity";
entity Year "/home/paul/data/code/cwi/pacioli/cases/case2/year.entity";
entity Region "/home/paul/data/code/cwi/pacioli/cases/case2/region.entity";
index Commodity unit "/home/paul/data/code/cwi/pacioli/cases/case2/commodity.unit";
entity Ingredient "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.entity";
entity Menu "/home/paul/data/code/cwi/pacioli/cases/case3/menu.entity";
index Ingredient unit "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient.unit";
conversion conv "Product" "bom_unit" "trade_unit";
projection P0 "Commodity,Year,Region.1" "Commodity.1";
projection P1 "Commodity,Year,Region.1" "Commodity,Year.1";
projection P2 "Year,Commodity.1,unit" "Commodity,Year,Region.unit,1,1";
entity Place "/home/paul/data/code/cwi/pacioli/cases/case4/place.entity";
entity Transition "/home/paul/data/code/cwi/pacioli/cases/case4/transition.entity";
index Place unit "/home/paul/data/code/cwi/pacioli/cases/case4/place.unit";
entity File "/home/paul/data/code/cwi/pacioli/cases/case5/file.entity";
entity Module "/home/paul/data/code/cwi/pacioli/cases/case5/module.entity";
entity Conspiracy "/home/paul/data/code/cwi/pacioli/cases/case4/conspiracy.entity";
load lines "/home/paul/data/code/cwi/pacioli/cases/case5/lines.csv" "loc" "Empty" "File.1.0";
load semi_bom "/home/paul/data/code/cwi/pacioli/cases/case3/semi_bom.csv" "1.0" "Ingredient.unit" "Menu.1.0";
load menu_price "/home/paul/data/code/cwi/pacioli/cases/case3/menu_price.csv" "dollar" "Empty" "Menu.1.0";
load isAsset "/home/paul/data/code/cwi/pacioli/cases/case4/isAsset.csv" "1.0" "Empty" "Place.1.0";
load backward "/home/paul/data/code/cwi/pacioli/cases/case4/backward.csv" "1.0" "Place.unit" "Transition.1.0";
load root "/home/paul/data/code/cwi/pacioli/cases/case5/root.csv" "1.0" "Module.1.0" "Empty";
load stock2 "/home/paul/data/code/cwi/pacioli/cases/case3/stock2.csv" "1.0" "Ingredient.unit" "Empty";
load stock1 "/home/paul/data/code/cwi/pacioli/cases/case3/stock1.csv" "1.0" "Ingredient.unit" "Empty";
load ingredient_price "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient_price.csv" "dollar" "Empty" "Ingredient.unit";
load amount "/home/paul/data/code/cwi/pacioli/cases/case2/amount.csv" "1.0" "Commodity,Year,Region.unit,1.0,1.0" "Empty";
load sales_price "/home/paul/data/code/cwi/pacioli/cases/case1/sales_price.csv" "dollar" "Empty" "Product.trade_unit";
load forward "/home/paul/data/code/cwi/pacioli/cases/case4/forward.csv" "1.0" "Place.unit" "Transition.1.0";
load bom "/home/paul/data/code/cwi/pacioli/cases/case1/bom.csv" "1.0" "Product.bom_unit" "Product.bom_unit";
load basis "/home/paul/data/code/cwi/pacioli/cases/case4/basis.csv" "1.0" "Transition.1.0" "Conspiracy.1.0";
load owner "/home/paul/data/code/cwi/pacioli/cases/case5/owner.csv" "1.0" "File.1.0" "Module.1.0";
load isLegit "/home/paul/data/code/cwi/pacioli/cases/case4/isLegit.csv" "1.0" "Transition.1.0" "Empty";
load isJournal "/home/paul/data/code/cwi/pacioli/cases/case4/isJournal.csv" "1.0" "Empty" "Place.1.0";
load menu_sales "/home/paul/data/code/cwi/pacioli/cases/case3/menu_sales.csv" "1.0" "Menu.1.0" "Empty";
load parent "/home/paul/data/code/cwi/pacioli/cases/case5/parent.csv" "1.0" "Module.1.0" "Module.1.0";
load fileSize "/home/paul/data/code/cwi/pacioli/cases/case5/fileSize.csv" "byte" "Empty" "File.1.0";
load sales "/home/paul/data/code/cwi/pacioli/cases/case2/sales.csv" "dollar" "Empty" "Commodity,Year,Region.1.0";
load purchase_price "/home/paul/data/code/cwi/pacioli/cases/case1/purchase_price.csv" "dollar" "Empty" "Product.trade_unit";
load output "/home/paul/data/code/cwi/pacioli/cases/case1/output.csv" "1.0" "Product.trade_unit" "Empty";
load valuation "/home/paul/data/code/cwi/pacioli/cases/case4/valuation.csv" "dollar" "Empty" "Place.unit";
load lines "/home/paul/data/code/cwi/pacioli/cases/case5/lines.csv" "loc" "Empty" "File.1.0";
load semi_bom "/home/paul/data/code/cwi/pacioli/cases/case3/semi_bom.csv" "1.0" "Ingredient.unit" "Menu.1.0";
load menu_price "/home/paul/data/code/cwi/pacioli/cases/case3/menu_price.csv" "dollar" "Empty" "Menu.1.0";
load isAsset "/home/paul/data/code/cwi/pacioli/cases/case4/isAsset.csv" "1.0" "Empty" "Place.1.0";
load backward "/home/paul/data/code/cwi/pacioli/cases/case4/backward.csv" "1.0" "Place.unit" "Transition.1.0";
load root "/home/paul/data/code/cwi/pacioli/cases/case5/root.csv" "1.0" "Module.1.0" "Empty";
load stock2 "/home/paul/data/code/cwi/pacioli/cases/case3/stock2.csv" "1.0" "Ingredient.unit" "Empty";
load stock1 "/home/paul/data/code/cwi/pacioli/cases/case3/stock1.csv" "1.0" "Ingredient.unit" "Empty";
load ingredient_price "/home/paul/data/code/cwi/pacioli/cases/case3/ingredient_price.csv" "dollar" "Empty" "Ingredient.unit";
load amount "/home/paul/data/code/cwi/pacioli/cases/case2/amount.csv" "1.0" "Commodity,Year,Region.unit,1.0,1.0" "Empty";
load sales_price "/home/paul/data/code/cwi/pacioli/cases/case1/sales_price.csv" "dollar" "Empty" "Product.trade_unit";
load forward "/home/paul/data/code/cwi/pacioli/cases/case4/forward.csv" "1.0" "Place.unit" "Transition.1.0";
load bom "/home/paul/data/code/cwi/pacioli/cases/case1/bom.csv" "1.0" "Product.bom_unit" "Product.bom_unit";
load basis "/home/paul/data/code/cwi/pacioli/cases/case4/basis.csv" "1.0" "Transition.1.0" "Conspiracy.1.0";
load owner "/home/paul/data/code/cwi/pacioli/cases/case5/owner.csv" "1.0" "File.1.0" "Module.1.0";
load isLegit "/home/paul/data/code/cwi/pacioli/cases/case4/isLegit.csv" "1.0" "Transition.1.0" "Empty";
load isJournal "/home/paul/data/code/cwi/pacioli/cases/case4/isJournal.csv" "1.0" "Empty" "Place.1.0";
load menu_sales "/home/paul/data/code/cwi/pacioli/cases/case3/menu_sales.csv" "1.0" "Menu.1.0" "Empty";
load parent "/home/paul/data/code/cwi/pacioli/cases/case5/parent.csv" "1.0" "Module.1.0" "Module.1.0";
load fileSize "/home/paul/data/code/cwi/pacioli/cases/case5/fileSize.csv" "byte" "Empty" "File.1.0";
load sales "/home/paul/data/code/cwi/pacioli/cases/case2/sales.csv" "dollar" "Empty" "Commodity,Year,Region.1.0";
load purchase_price "/home/paul/data/code/cwi/pacioli/cases/case1/purchase_price.csv" "dollar" "Empty" "Product.trade_unit";
load output "/home/paul/data/code/cwi/pacioli/cases/case1/output.csv" "1.0" "Product.trade_unit" "Empty";
load valuation "/home/paul/data/code/cwi/pacioli/cases/case4/valuation.csv" "dollar" "Empty" "Place.unit";
eval combis lambda (list) application(apply, lambda (result, dummy) result, application(loopList, application(tuple,emptyList,list), lambda (accu, x) application(apply, lambda (result, tails) application(tuple,application(append, application(loopList, emptyList, lambda (accu, y) application(addMut, accu, application(tuple,x,y)), application(tail, tails)), result),application(tail, tails)), accu), list));
eval columns lambda (matrix) application(loopList, emptyList, lambda (accu, j) application(addMut, accu, application(column, matrix, j)), application(columnDomain, matrix));
eval rows lambda (matrix) application(loopList, emptyList, lambda (accu, i) application(addMut, accu, application(row, matrix, i)), application(rowDomain, matrix));
eval eliminate lambda (quadruples, row) application(loopList, emptyList, lambda (accu, c) application(apply, lambda (v, w) application(apply, lambda (v1, sv2, v2, sv2) application(apply, lambda (w1, sw1, w2, sw2) application(lambda (alpha) application(lambda (beta) if(application(less, application(multiply, alpha, beta), 0.00),application(lambda (scaled1) application(lambda (scaled2) application(addMut, accu, application(tuple,scaled1,application(support, scaled1),scaled2,application(support, scaled2))), application(sum, application(scale, application(abs, beta), v2), application(scale, application(abs, alpha), w2))), application(sum, application(scale, application(abs, beta), v1), application(scale, application(abs, alpha), w1))),accu), application(magnitude, w1, row, empty)), application(magnitude, v1, row, empty)), w), v), c), application(combis, quadruples));
eval canonical lambda (quadruple) application(apply, lambda (v1, sv1, v2, sv2) application(lambda (c) application(tuple,application(scale, c, v1),sv1,application(scale, c, v2),sv2), application(multiply, 1.00, application(reciprocal, application(gcd, application(loopMatrix, 0.0, lambda (accu, i, j) application(gcd, accu, application(magnitude, v1, i, j)), v1), application(loopMatrix, 0.0, lambda (accu, i, j) application(gcd, accu, application(magnitude, v2, i, j)), v2))))), quadruple);
eval normalize lambda (quadruples, row) application(loopList, emptyList, lambda (accu, v) application(apply, lambda (v1, sv1, v2, sv2) if(application(equal, application(magnitude, v1, row, empty), 0.00),application(addMut, accu, application(canonical, v)),accu), v), quadruples);
eval minimize lambda (quadruples) application(loopList, emptyList, lambda (prev, quadruple) application(apply, lambda (n1, sn1, n2, sn2) application(apply, lambda (bit, new) if(bit,application(addMut, new, quadruple),new), application(loopList, application(tuple,true,emptyList), lambda (accu, p) application(apply, lambda (bit, new) application(apply, lambda (p1, sp1, p2, sp2) if(and(application(lessEq, sn1, sp1),application(lessEq, sn2, sp2)),application(tuple,false,if(bit,application(addMut, new, quadruple),new)),application(tuple,and(bit,application(not, and(application(lessEq, sp1, sn1),application(lessEq, sp2, sn2)))),application(addMut, new, p))), p), accu), prev)), quadruple), quadruples);
eval driver lambda (quadruples, row) application(lambda (eliminated) application(lambda (normalized) application(lambda (bases) application(lambda (dummy) bases, application(print, application(tuple,row,application(size, eliminated),application(size, normalized),application(size, bases)))), application(minimize, normalized)), application(normalize, application(append, eliminated, quadruples), row)), application(eliminate, quadruples, row));
eval fourierMotzkin lambda (matrix) application(lambda (quadruples) application(loopList, emptyList, lambda (accu, p) application(apply, lambda (p1, sp1, p2, sp2) application(addMut, accu, p2), p), application(loopList, quadruples, driver, application(rowDomain, matrix))), application(loopList, emptyList, lambda (accu, pair) application(apply, lambda (p1, p2) application(addMut, accu, application(tuple,p1,application(support, p1),p2,application(support, p2))), pair), application(zip, application(columns, matrix), application(columns, application(rightIdentity, matrix)))));
eval result application(loopList, emptyList, lambda (accu, j) application(lambda (col) if(application(not, application(equal, application(join, application(sum, backward, application(negative, forward)), col), 0.00)),application(addMut, accu, j),accu), application(column, basis, j)), application(columnDomain, basis)); 
print result